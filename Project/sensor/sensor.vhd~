library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;
use ieee.std_logic_arith.all;
use work.PulseLengthDecoderPackage.all;

entity sensor is
	port (clock : in std_logic; -- 1 clock cycle = 20ns
			reset : in std_logic;
			selByte : in std_logic;
			oneWireData : inout std_logic;
			leds : out std_logic_vector(7 downto 0));
end sensor;

architecture behaviour of sensor is

	type stateType is (Standby, Sending, Waiting, Presence, Prepare, Sleep, Data, IndexIncrement, Done);
	type pulseLengthsArray is array (1 to 40) of integer;

	signal currentState, nextState : stateType := Standby;

	signal standbyCounter, sendingCounter, waitingLength, presenceCounter, prepareCounter : integer := 0;
	signal pulseLengths : pulseLengthsArray := (0, 0, 0, 0, 0, 0, 0, 0,
															  0, 0, 0, 0, 0, 0, 0, 0,
															  0, 0, 0, 0, 0, 0, 0, 0,
															  0, 0, 0, 0, 0, 0, 0, 0,
															  0, 0, 0, 0, 0, 0, 0, 0);
	signal indexIncCounter : integer := 0;
	signal sleepCounter : integer := 0;
	signal doneCounter : integer := 0;

	signal enStandby : bit := '0';
	signal enSending : bit := '0';
	signal enWaiting : bit := '0';
	signal enPresence : bit := '0';
	signal enPrepare : bit := '0';
	signal enSleep : bit := '0';
	signal enData : bit := '0';
	signal enIndexInc : bit := '0';
	signal enDone : bit := '0';

	signal dataIndex : integer := 1;

	signal humidity : std_logic_vector(15 downto 0) := "0000000000000000";
	signal humidityValid : std_logic_vector(15 downto 0) := "0000000000000000";
	signal temperature : std_logic_vector(15 downto 0) := "0000000000000000";
	signal temperatureValid : std_logic_vector(15 downto 0) := "0000000000000000";
	signal checksum : std_logic_vector(7 downto 0) := "00000000";
	signal checksumValid : std_logic_vector(7 downto 0) := "00000000";

	signal pulseLength : std_logic_vector(15 downto 0) := "0000000000000000";

	signal dataIn, dataOut : std_logic := '0';

	begin

		-- pulseLength <= conv_std_logic_vector(pulseLengths(9), 16);

		with selByte select
			leds <= humidityValid(15 downto 8) when '1',
					  humidityValid(7 downto 0) when '0',
					  "00000000" when others;

		-- humidity
		bit01: PulseLengthDecoder port map (pulseLengths(1), humidity(15), humidityValid(15));
		bit02: PulseLengthDecoder port map (pulseLengths(2), humidity(14), humidityValid(14));
		bit03: PulseLengthDecoder port map (pulseLengths(3), humidity(13), humidityValid(13));
		bit04: PulseLengthDecoder port map (pulseLengths(4), humidity(12), humidityValid(12));
		bit05: PulseLengthDecoder port map (pulseLengths(5), humidity(11), humidityValid(11));
		bit06: PulseLengthDecoder port map (pulseLengths(6), humidity(10), humidityValid(10));
		bit07: PulseLengthDecoder port map (pulseLengths(7), humidity(9), humidityValid(9));
		bit08: PulseLengthDecoder port map (pulseLengths(8), humidity(8), humidityValid(8));
		bit09: PulseLengthDecoder port map (pulseLengths(9), humidity(7), humidityValid(7));
		bit10: PulseLengthDecoder port map (pulseLengths(10), humidity(6), humidityValid(6));
		bit11: PulseLengthDecoder port map (pulseLengths(11), humidity(5), humidityValid(5));
		bit12: PulseLengthDecoder port map (pulseLengths(12), humidity(4), humidityValid(4));
		bit13: PulseLengthDecoder port map (pulseLengths(13), humidity(3), humidityValid(3));
		bit14: PulseLengthDecoder port map (pulseLengths(14), humidity(2), humidityValid(2));
		bit15: PulseLengthDecoder port map (pulseLengths(15), humidity(1), humidityValid(1));
		bit16: PulseLengthDecoder port map (pulseLengths(16), humidity(0), humidityValid(0));

		-- temperature
		bit17: PulseLengthDecoder port map (pulseLengths(17), temperature(15), temperatureValid(15));
		bit18: PulseLengthDecoder port map (pulseLengths(18), temperature(14), temperatureValid(14));
		bit19: PulseLengthDecoder port map (pulseLengths(19), temperature(13), temperatureValid(13));
		bit20: PulseLengthDecoder port map (pulseLengths(20), temperature(12), temperatureValid(12));
		bit21: PulseLengthDecoder port map (pulseLengths(21), temperature(11), temperatureValid(11));
		bit22: PulseLengthDecoder port map (pulseLengths(22), temperature(10), temperatureValid(10));
		bit23: PulseLengthDecoder port map (pulseLengths(23), temperature(9), temperatureValid(9));
		bit24: PulseLengthDecoder port map (pulseLengths(24), temperature(8), temperatureValid(8));
		bit25: PulseLengthDecoder port map (pulseLengths(25), temperature(7), temperatureValid(7));
		bit26: PulseLengthDecoder port map (pulseLengths(26), temperature(6), temperatureValid(6));
		bit27: PulseLengthDecoder port map (pulseLengths(27), temperature(5), temperatureValid(5));
		bit28: PulseLengthDecoder port map (pulseLengths(28), temperature(4), temperatureValid(4));
		bit29: PulseLengthDecoder port map (pulseLengths(29), temperature(3), temperatureValid(3));
		bit30: PulseLengthDecoder port map (pulseLengths(30), temperature(2), temperatureValid(2));
		bit31: PulseLengthDecoder port map (pulseLengths(31), temperature(1), temperatureValid(1));
		bit32: PulseLengthDecoder port map (pulseLengths(32), temperature(0), temperatureValid(0));

		-- checksum
		bit33: PulseLengthDecoder port map (pulseLengths(33), checksum(7), checksumValid(7));
		bit34: PulseLengthDecoder port map (pulseLengths(34), checksum(6), checksumValid(6));
		bit35: PulseLengthDecoder port map (pulseLengths(35), checksum(5), checksumValid(5));
		bit36: PulseLengthDecoder port map (pulseLengths(36), checksum(4), checksumValid(4));
		bit37: PulseLengthDecoder port map (pulseLengths(37), checksum(3), checksumValid(3));
		bit38: PulseLengthDecoder port map (pulseLengths(38), checksum(2), checksumValid(2));
		bit39: PulseLengthDecoder port map (pulseLengths(39), checksum(1), checksumValid(1));
		bit40: PulseLengthDecoder port map (pulseLengths(40), checksum(0), checksumValid(0));

		process (clock, reset) begin
			if (reset = '1') then
				currentState <= Standby;
				standbyCounter <= 0;
				sendingCounter <= 0;
				waitingLength <= 0;
				presenceCounter <= 0;
				prepareCounter <= 0;
				pulseLengths <= (0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
				indexIncCounter <= 0;
				sleepCounter <= 0;
				doneCounter <= 0;
			elsif (clock'event and clock = '1') then
				currentState <= nextState;
				data <= dataOut;
				dataIn <= data;
				currentOneWireData <= nextOneWireDate;
				if (enStandby = '1') then
					standbyCounter <= standbyCounter + 1;
				elsif (enSending = '1') then
					sendingCounter <= sendingCounter + 1;
				elsif (enWaiting = '1') then
					waitingLength <= waitingLength + 1;
				elsif (enPresence = '1') then
					presenceCounter <= presenceCounter + 1;
				elsif (enPrepare = '1') then
					prepareCounter <= prepareCounter + 1;
				elsif (enSleep = '1') then
					sleepCounter <= sleepCounter + 1;
				elsif (enData = '1') then
					if (dataIndex = 1) then
						pulseLengths(1) <= pulseLengths(1) + 1;
					elsif (dataIndex = 2) then
						pulseLengths(2) <= pulseLengths(2) + 1;
					elsif (dataIndex = 3) then
						pulseLengths(3) <= pulseLengths(3) + 1;
					elsif (dataIndex = 4) then
						pulseLengths(4) <= pulseLengths(4) + 1;
					elsif (dataIndex = 5) then
						pulseLengths(5) <= pulseLengths(5) + 1;
					elsif (dataIndex = 6) then
						pulseLengths(6) <= pulseLengths(6) + 1;
					elsif (dataIndex = 7) then
						pulseLengths(7) <= pulseLengths(7) + 1;
					elsif (dataIndex = 8) then
						pulseLengths(8) <= pulseLengths(8) + 1;
					elsif (dataIndex = 9) then
						pulseLengths(9) <= pulseLengths(9) + 1;
					elsif (dataIndex = 10) then
						pulseLengths(10) <= pulseLengths(10) + 1;
					elsif (dataIndex = 11) then
						pulseLengths(11) <= pulseLengths(11) + 1;
					elsif (dataIndex = 12) then
						pulseLengths(12) <= pulseLengths(12) + 1;
					elsif (dataIndex = 13) then
						pulseLengths(13) <= pulseLengths(13) + 1;
					elsif (dataIndex = 14) then
						pulseLengths(14) <= pulseLengths(14) + 1;
					elsif (dataIndex = 15) then
						pulseLengths(15) <= pulseLengths(15) + 1;
					elsif (dataIndex = 16) then
						pulseLengths(16) <= pulseLengths(16) + 1;
					elsif (dataIndex = 17) then
						pulseLengths(17) <= pulseLengths(17) + 1;
					elsif (dataIndex = 18) then
						pulseLengths(18) <= pulseLengths(18) + 1;
					elsif (dataIndex = 19) then
						pulseLengths(19) <= pulseLengths(19) + 1;
					elsif (dataIndex = 20) then
						pulseLengths(20) <= pulseLengths(20) + 1;
					elsif (dataIndex = 21) then
						pulseLengths(21) <= pulseLengths(21) + 1;
					elsif (dataIndex = 22) then
						pulseLengths(22) <= pulseLengths(22) + 1;
					elsif (dataIndex = 23) then
						pulseLengths(23) <= pulseLengths(23) + 1;
					elsif (dataIndex = 24) then
						pulseLengths(24) <= pulseLengths(24) + 1;
					elsif (dataIndex = 25) then
						pulseLengths(25) <= pulseLengths(25) + 1;
					elsif (dataIndex = 26) then
						pulseLengths(26) <= pulseLengths(26) + 1;
					elsif (dataIndex = 27) then
						pulseLengths(27) <= pulseLengths(27) + 1;
					elsif (dataIndex = 28) then
						pulseLengths(28) <= pulseLengths(28) + 1;
					elsif (dataIndex = 29) then
						pulseLengths(29) <= pulseLengths(29) + 1;
					elsif (dataIndex = 30) then
						pulseLengths(30) <= pulseLengths(30) + 1;
					elsif (dataIndex = 31) then
						pulseLengths(31) <= pulseLengths(31) + 1;
					elsif (dataIndex = 32) then
						pulseLengths(32) <= pulseLengths(32) + 1;
					elsif (dataIndex = 33) then
						pulseLengths(33) <= pulseLengths(33) + 1;
					elsif (dataIndex = 34) then
						pulseLengths(34) <= pulseLengths(34) + 1;
					elsif (dataIndex = 35) then
						pulseLengths(35) <= pulseLengths(35) + 1;
					elsif (dataIndex = 36) then
						pulseLengths(36) <= pulseLengths(36) + 1;
					elsif (dataIndex = 37) then
						pulseLengths(37) <= pulseLengths(37) + 1;
					elsif (dataIndex = 38) then
						pulseLengths(38) <= pulseLengths(38) + 1;
					elsif (dataIndex = 39) then
						pulseLengths(39) <= pulseLengths(39) + 1;
					elsif (dataIndex = 40) then
						pulseLengths(40) <= pulseLengths(40) + 1;
					end if;
					sleepCounter <= 0;
					indexIncCounter <= 0;
				elsif (enIndexInc = '1') then
					dataIndex <= dataIndex + 1;
					indexIncCounter <= indexIncCounter + 1;
				elsif (enDone = '1') then
					doneCounter <= doneCounter + 1;
				else
					--
				end if;
			end if;
		end process;

		process (dataIn, standbyCounter, sendingCounter, presenceCounter, prepareCounter, sleepCounter, indexIncCounter, doneCounter) begin
			case currentState is
				when Standby =>
					-- Standby for 50,000,000 x 20ns = 1s
					if (standbyCounter = 50000000) then
						nextState <= Sending;
					else
						nextState <= Standby;
					end if;
				when Sending =>
					-- Send 400,000 x 20ns = 8ms '0' pulse
					if (sendingCounter = 400000) then
						nextState <= Waiting;
					else
						nextState <= Sending;
					end if;
				when Waiting =>
					if (oneWireData = '0') then
						nextState <= Presence;
					else
						nextState <= Waiting;
					end if;
				when Presence =>
					-- 80us '0' presence state
					if (presenceCounter = 4000) then
						nextState <= Prepare;
					else
						nextState <= Presence;
					end if;
				when Prepare =>
					if (prepareCounter = 4000) then
						nextState <= Sleep;
					else
						nextState <= Prepare;
					end if;
				when Sleep =>
					-- Sleep for 55us = 2750 clock cycles
					if (sleepCounter = 3250) then
						nextState <= Data;
					else
						nextState <= Sleep;
					end if;
				when Data =>
					if (dataIndex = 40) then
						nextState <= Done;
					else
						if (oneWireData = '0') then
							nextState <= IndexIncrement;
						else
							nextState <= Data;
						end if;
					end if;
				when IndexIncrement =>
					if (indexIncCounter = 0) then
						nextState <= Sleep;
					else
						nextState <= IndexIncrement;
					end if;
				when Done =>
					nextState <= Done;
			end case;
		end process;

		process (currentState) begin
			if (currentState = Standby) then
				dataOut <= 'Z';
				enStandby <= '1';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = Sending) then
				dataOut <= '0';
				enStandby <= '0';
				enSending <= '1';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = Waiting) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '1';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = Presence) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '1';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = Prepare) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '1';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = Sleep) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '1';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = Data) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '1';
				enIndexInc <= '0';
				enDone <= '0';
			elsif (currentState = IndexIncrement) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '1';
				enDone <= '0';
			elsif (currentState = Done) then
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '1';
			else
				dataOut <= 'Z';
				enStandby <= '0';
				enSending <= '0';
				enWaiting <= '0';
				enPresence <= '0';
				enPrepare <= '0';
				enSleep <= '0';
				enData <= '0';
				enIndexInc <= '0';
				enDone <= '0';
			end if;
		end process;

end behaviour;
























